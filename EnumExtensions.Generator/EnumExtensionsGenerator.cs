using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EnumExtensions.Generator
{
    [Generator]
    internal class EnumExtensionsGenerator : IIncrementalGenerator
    {
        private const string GenerateExtensionsAttribute = "EnumExtensions.GenerateExtensionsAttribute";
        
        private const string Random = "global::System.Random";
        private const string IEnumerable = "global::System.Collections.Generic.IEnumerable";
        private const string Func = "global::System.Func";
        private const string Action = "global::System.Action";
        private const string Exception = "global::System.Exception";
        private const string FormatException = "global::System.FormatException";
        private const string ArgumentOutOfRangeException = "global::System.ArgumentOutOfRangeException";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(GenerateExtensionsAttribute,
                    predicate: static (x, _) => x is EnumDeclarationSyntax,
                    transform: static (x, _) => GetEnumInfo(x))
                .Where(x => x is not null);

            context.RegisterSourceOutput(provider, Execute);
        }

        private class EnumInfo
        {
            public EnumDeclarationSyntax Syntax { get; set; } = null!;
            public INamedTypeSymbol Symbol { get; set; } = null!;

            public string? ClassName { get; set; }
            public string? Namespace { get; set; }
            
            public string EnumName => Symbol.ToFullyQualifiedDisplayString();
        }

        private static EnumInfo? GetEnumInfo(GeneratorAttributeSyntaxContext context)
        {
            if ((context.TargetSymbol is INamedTypeSymbol enumSymbol) == false || enumSymbol.TypeKind != TypeKind.Enum)
            {
                return null;
            }

            string? ns = null;
            string? className = null;

            foreach (var attribute in context.Attributes)
            {
                if (attribute.AttributeClass?.Is(GenerateExtensionsAttribute) == false)
                    continue;

                foreach (var namedArgument in attribute.NamedArguments)
                {
                    if (namedArgument.Key == "ClassName")
                    {
                        className = namedArgument.Value.Value?.ToString();
                    }
                    else if (namedArgument.Key == "Namespace")
                    {
                        ns = namedArgument.Value.Value?.ToString();
                    }
                }
            }

            return new EnumInfo
            {
                Syntax = (EnumDeclarationSyntax)context.TargetNode,
                Symbol = enumSymbol,
                ClassName = className,
                Namespace = ns,
            };
        }

        private static void Execute(SourceProductionContext context, EnumInfo? info)
        {
            if (info is null) return;

            context.CancellationToken.ThrowIfCancellationRequested();

            var ns = info.Namespace;
            if (ns == null && info.Symbol.ContainingNamespace != null && info.Symbol.ContainingNamespace.IsGlobalNamespace == false)
            {
                ns = info.Symbol.ContainingNamespace.ToDisplayString();
            }

            var className = info.ClassName ?? info.Symbol.Name + "Extensions";

            var members = info.Symbol.GetMembers().OfType<IFieldSymbol>().ToArray();

            var name = className;
            if (string.IsNullOrWhiteSpace(ns) == false)
            {
                name = $"{ns}.{name}".Replace("::", "_").Replace(".", "_");
            }
            context.AddSource($"{name}.g.cs", Emit(info, ns, className, members));
        }

        private static string Emit(EnumInfo info, string? @namespace, string className, IFieldSymbol[] members)
        {
            var enumName = info.EnumName;
            var hasNamespace = string.IsNullOrWhiteSpace(@namespace) == false;

            var builder = new CodeWriter();

            builder
                .WriteLine("// <auto-generated/>")
                .WriteLine("#nullable enable");

            builder.WriteLineIf(hasNamespace, $"namespace {@namespace}");
            using (builder.BeginScopeIf(hasNamespace))
            {
                builder.WriteLine($"public static partial class {className}");
                using (builder.BeginScope())
                {
                    builder.WriteLine($"private static readonly {Random} _rng = new {Random}();");
                    
                    builder.WriteLine($"private static readonly {enumName}[] _values = new {enumName}[]");
                    using (builder.BeginScope(end: "};"))
                    {
                        foreach (var member in members)
                        {
                            builder.WriteLine($"{enumName}.{member.Name},");
                        }
                    }
                    
                    builder.WriteLine("private static readonly string[] _names = new string[]");
                    using (builder.BeginScope(end: "};"))
                    {
                        foreach (var member in members)
                        {
                            builder.WriteLine($"\"{member.Name}\",");
                        }
                    }
                    
                    WriteIsMethods(info, members, builder);
                    WriteEnumerablesAndArrays(info, members, builder);
                    
                    builder.WriteLine($"public static string ToStringFast(this {enumName} value) => value switch");
                    using (builder.BeginScope(end: "};"))
                    {
                        foreach (var member in members)
                        {
                            builder.WriteLine($"{enumName}.{member.Name} => \"{member.Name}\",");
                        }
                        builder.WriteLine("_ => value.ToString()");
                    }
                    
                    WriteCycleMethods(info, members, builder);
                    WriteRandomMethods(enumName, builder);
                    WriteParseMethods(info, members, builder);
                }
            }

            return builder.ToString();
        }

        private static void WriteIsMethods(EnumInfo info, IFieldSymbol[] members, CodeWriter builder)
        {
            var enumName = info.EnumName;

            foreach (var member in members)
            {
                builder.WriteLine("/// <summary>");
                builder.WriteLine($"/// Checks if the specified <see cref=\"{enumName}\"/> is equal to <c>{member.Name}</c>.");
                builder.WriteLine($"/// Shorthand for <c>value == {enumName}.{member.Name}</c>.");
                builder.WriteLine("/// </summary>");
                builder.WriteLine($"/// <param name=\"value\">The <see cref=\"{enumName}\"/> to evaluate.</param>");
                builder.WriteLine($"/// <returns><c>true</c> if the specified <see cref=\"{enumName}\"/> is <c>{member.Name}</c>; otherwise, <c>false</c>.</returns>");
                builder.WriteLine($"public static bool Is{member.Name}(this {enumName} value) => value == {enumName}.{member.Name};");
            }
        }

        private static void WriteEnumerablesAndArrays(EnumInfo info, IFieldSymbol[] members, CodeWriter builder)
        {
            var enumName = info.EnumName;

            builder
                .WriteLine($"public static {enumName}[] GetValues() => _values;")
                .WriteLine("public static string[] GetNames() => _names;");

            builder.WriteLine($"public static {IEnumerable}<{enumName}> GetValuesEnumerable()");
            using (builder.BeginScope())
            {
                foreach (var member in members)
                {
                    builder.WriteLine($"yield return {enumName}.{member.Name};");
                }
            }

            builder.WriteLine($"public static {IEnumerable}<string> GetNamesEnumerable()");
            using (builder.BeginScope())
            {
                foreach (var member in members)
                {
                    builder.WriteLine($"yield return \"{member.Name}\";");
                }
            }
        }

        private static void WriteCycleMethods(EnumInfo info, IFieldSymbol[] members, CodeWriter builder)
        {
            var enumName = info.EnumName;

            var cycleOrderNext = "";
            var cycleOrderPrev = "";
            for (var i = 0; i < members.Length; i++)
            {
                var k = members.Length - i - 1;
                var member = members[i];
                var nextMember = members[(i + 1) % members.Length];
                var prevMember = members[(k + members.Length - 1) % members.Length];
                cycleOrderNext += $"{member.Name} -> {nextMember.Name}";
                cycleOrderPrev += $"{members[k].Name} -> {prevMember.Name}";
                if (i < members.Length - 1)
                {
                    cycleOrderNext += ", ";
                    cycleOrderPrev += ", ";
                }
            }

            builder
                .WriteLine("/// <summary>")
                .WriteLine("/// Returns the next enum value in the declaration order, wrapping back to the first value")
                .WriteLine("/// if <paramref name=\"value\"/> is the last one.")
                .WriteLine($"/// {cycleOrderNext}.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <param name=\"value\">The current <see cref=\"{enumName}\"/> value.</param>")
                .WriteLine("/// <returns>")
                .WriteLine("/// The enum value immediately following <paramref name=\"value\"/> in declaration order,")
                .WriteLine("/// or the first declared value if <paramref name=\"value\"/> is the last.")
                .WriteLine("/// </returns>")
                .WriteLine("/// <exception cref=\"global::System.ArgumentOutOfRangeException\">")
                .WriteLine($"/// Thrown when <paramref name=\"value\"/> is not a valid <see cref=\"{enumName}\"/> value.")
                .WriteLine("/// </exception>");

            builder.WriteLine($"public static {enumName} Next(this {enumName} value) => value switch");
            using (builder.BeginScope(end: "};"))
            {
                for (var i = 0; i < members.Length; i++)
                {
                    var member = members[i];
                    var nextMember = members[(i + 1) % members.Length];
                    builder.WriteLine($"{enumName}.{member.Name} => {enumName}.{nextMember.Name},");
                }
                builder.WriteLine($"_ => throw new {ArgumentOutOfRangeException}(nameof(value))");
            }

            builder
                .WriteLine("/// <summary>")
                .WriteLine("/// Returns the previous enum value in the declaration order, wrapping back to the last value")
                .WriteLine("/// if <paramref name=\"value\"/> is the first one.")
                .WriteLine($"/// {cycleOrderPrev}.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <param name=\"value\">The current <see cref=\"{enumName}\"/> value.</param>")
                .WriteLine("/// <returns>")
                .WriteLine("/// The enum value immediately preceding <paramref name=\"value\"/> in declaration order,")
                .WriteLine("/// or the last declared value if <paramref name=\"value\"/> is the first.")
                .WriteLine("/// </returns>")
                .WriteLine("/// <exception cref=\"global::System.ArgumentOutOfRangeException\">")
                .WriteLine($"/// Thrown when <paramref name=\"value\"/> is not a valid <see cref=\"{enumName}\"/> value.")
                .WriteLine("/// </exception>");

            builder.WriteLine($"public static {enumName} Previous(this {enumName} value) => value switch");
            using (builder.BeginScope(end: "};"))
            {
                for (var i = members.Length - 1; i >= 0; i--)
                {
                    var member = members[i];
                    var prevMember = members[(i + members.Length - 1) % members.Length];
                    builder.WriteLine($"{enumName}.{member.Name} => {enumName}.{prevMember.Name},");
                }
                builder.WriteLine($"_ => throw new {ArgumentOutOfRangeException}(nameof(value))");
            }
        }

        private static void WriteRandomMethods(string enumName, CodeWriter builder)
        {
            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Returns a random <see cref=\"{enumName}\"/> value.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <returns>A random <see cref=\"{enumName}\"/> value.</returns>");

            builder.WriteLine($"public static {enumName} GetRandomValue() => GetRandomValue(_rng);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Returns a random <see cref=\"{enumName}\"/> value, excluding the specified values.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <param name=\"excluded\">The values to exclude.</param>")
                .WriteLine($"/// <returns>A random <see cref=\"{enumName}\"/> value, excluding the specified values.</returns>");

            builder.WriteLine($"public static {enumName} GetRandomValueExcluding(params {enumName}[] excluded) => GetRandomValueExcluding(_rng, excluded);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Returns a random <see cref=\"{enumName}\"/> value.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <param name=\"random\">The random number generator to use.</param>")
                .WriteLine($"/// <returns>A random <see cref=\"{enumName}\"/> value.</returns>");

            builder.WriteLine($"public static {enumName} GetRandomValue({Random} random) => _values[random.Next(_values.Length)];");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Returns a random <see cref=\"{enumName}\"/> value, excluding the specified values.")
                .WriteLine("/// </summary>")
                .WriteLine($"/// <param name=\"random\">The random number generator to use.</param>")
                .WriteLine($"/// <param name=\"excluded\">The values to exclude.</param>")
                .WriteLine($"/// <returns>A random <see cref=\"{enumName}\"/> value.</returns>");

            builder.WriteLine($"public static {enumName} GetRandomValueExcluding({Random} random, params {enumName}[] excluded)");
            using (builder.BeginScope())
            {
                builder.WriteLine($"var valid = new {enumName}[_values.Length - excluded.Length];");
                builder.WriteLine("var validCount = 0;");
                builder.WriteLine("for (var i = 0; i < _values.Length; i++)");
                using (builder.BeginScope())
                {
                    builder.WriteLine("var val = _values[i];");
                    builder.WriteLine("foreach (var ex in excluded)");
                    using (builder.BeginScope())
                    {
                        builder.WriteLine("if (val != ex)");
                        using (builder.BeginScope())
                        {
                            builder.WriteLine("valid[validCount++] = val;");
                            builder.WriteLine("break;");
                        }
                    }
                }
                builder.WriteLine("return valid[random.Next(validCount)];");
            }
        }

        private static void WriteParseMethods(EnumInfo info, IFieldSymbol[] members, CodeWriter builder)
        {
            var enumName = info.Symbol.Name;
            var fullEnumName = info.EnumName;

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Attempts to parse the string representation of a <see cref=\"{fullEnumName}\"/> value.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"result\">When this method returns, contains the parsed <see cref=\"{fullEnumName}\"/> value, if the parsing succeeded; otherwise, the default value.</param>")
                .WriteLine("/// <returns><c>true</c> if the parsing succeeded; otherwise, <c>false</c>.</returns>");

            builder.WriteLine($"public static bool TryParse{enumName}(this string s, out {fullEnumName} result)");
            using (builder.BeginScope())
            {
                builder.WriteLine("switch (s)");
                using (builder.BeginScope())
                {
                    foreach (var member in members)
                    {
                        builder.WriteLine($"case \"{member.Name}\": result = {fullEnumName}.{member.Name}; return true;");
                    }
                    builder.WriteLine("default: result = default; return false;");
                }
            }

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Attempts to parse the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"result\">When this method returns, contains the parsed <see cref=\"{fullEnumName}\"/> value, if the parsing succeeded; otherwise, the default value.</param>")
                .WriteLine("/// <returns><c>true</c> if the parsing succeeded; otherwise, <c>false</c>.</returns>");

            builder.WriteLine($"public static bool TryParse{enumName}IgnoreCase(this string s, out {fullEnumName} result)");
            using (builder.BeginScope())
            {
                builder.WriteLine("switch (s.ToLower())");
                using (builder.BeginScope())
                {
                    foreach (var member in members)
                    {
                        builder.WriteLine($"case \"{member.Name.ToLower()}\": result = {fullEnumName}.{member.Name}; return true;");
                    }
                    builder.WriteLine("default: result = default; return false;");
                }
            }

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or <c>null</c> if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or <c>null</c> if parsing fails.</returns>");

            builder.WriteLine($"public static {fullEnumName}? Parse{enumName}(this string s) => TryParse{enumName}(s, out var result) ? result : null;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or <c>null</c> if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or <c>null</c> if parsing fails.</returns>");

            builder.WriteLine($"public static {fullEnumName}? Parse{enumName}IgnoreCase(this string s) => TryParse{enumName}IgnoreCase(s, out var result) ? result : null;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or a default value if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"defaultValue\">The default value to return if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or <c>defaultValue</c> if parsing fails.</returns>");

            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrDefault(this string s, {fullEnumName} defaultValue) => TryParse{enumName}(s, out var result) ? result : defaultValue;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or a default value if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"defaultValue\">The default value to return if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or <c>defaultValue</c> if parsing fails.</returns>");

            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrDefaultIgnoreCase(this string s, {fullEnumName} defaultValue) => TryParse{enumName}IgnoreCase(s, out var result) ? result : defaultValue;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>")
                .WriteLine($"/// <exception cref=\"System.FormatException\">Thrown if parsing fails.</exception>");

            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrow(this string s) => TryParse{enumName}(s, out var result) ? result : throw new {FormatException}($\"{{s}} is not a valid {fullEnumName}\");");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>")
                .WriteLine($"/// <exception cref=\"System.FormatException\">Thrown if parsing fails.</exception>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrowIgnoreCase(this string s) => TryParse{enumName}IgnoreCase(s, out var result) ? result : throw new {FormatException}($\"{{s}} is not a valid {fullEnumName}\");");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"message\">The message to include in the exception thrown if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>")
                .WriteLine($"/// <exception cref=\"System.FormatException\">Thrown if parsing fails.</exception>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrow(this string s, string message) => TryParse{enumName}(s, out var result) ? result : throw new {FormatException}(message);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"message\">The message to include in the exception thrown if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>")
                .WriteLine($"/// <exception cref=\"System.FormatException\">Thrown if parsing fails.</exception>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrowIgnoreCase(this string s, string message) => TryParse{enumName}IgnoreCase(s, out var result) ? result : throw new {FormatException}(message);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"exception\">The exception to throw if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrow(this string s, {Exception} exception) => TryParse{enumName}(s, out var result) ? result : throw exception;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or throws an exception if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"exception\">The exception to throw if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value.</returns>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrThrowIgnoreCase(this string s, {Exception} exception) => TryParse{enumName}IgnoreCase(s, out var result) ? result : throw exception;");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or returns the fallback value if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"fallback\">The fallback value to return if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or the fallback value if parsing fails.</returns>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrElse(this string s, {Func}<string, {fullEnumName}> fallback) => TryParse{enumName}(s, out var result) ? result : fallback(s);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or returns the fallback value if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"fallback\">The fallback value to return if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or the fallback value if parsing fails.</returns>");
            builder.WriteLine($"public static {fullEnumName} Parse{enumName}OrElseIgnoreCase(this string s, {Func}<string, {fullEnumName}> fallback) => TryParse{enumName}IgnoreCase(s, out var result) ? result : fallback(s);");

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value and returns it, or returns null if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"onError\">The action to invoke if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or null if parsing fails.</returns>");
            builder.WriteLine($"public static {fullEnumName}? Parse{enumName}OrElse(this string s, {Action}<string> onError)");
            using (builder.BeginScope())
            {
                builder.WriteLine($"if (TryParse{enumName}(s, out var result))");
                using (builder.BeginScope())
                {
                    builder.WriteLine("return result;");
                }
                builder.WriteLine("onError(s);");
                builder.WriteLine("return null;");
            }

            builder
                .WriteLine("/// <summary>")
                .WriteLine($"/// Parses the string representation of a <see cref=\"{fullEnumName}\"/> value, ignoring case, and returns it, or returns null if parsing fails.")
                .WriteLine("/// </summary>")
                .WriteLine("/// <param name=\"s\">The string to parse.</param>")
                .WriteLine($"/// <param name=\"onError\">The action to invoke if parsing fails.</param>")
                .WriteLine($"/// <returns>The parsed <see cref=\"{fullEnumName}\"/> value, or null if parsing fails.</returns>");
            builder.WriteLine($"public static {fullEnumName}? Parse{enumName}OrElseIgnoreCase(this string s, {Action}<string> onError)");
            using (builder.BeginScope())
            {
                builder.WriteLine($"if (TryParse{enumName}IgnoreCase(s, out var result))");
                using (builder.BeginScope())
                {
                    builder.WriteLine("return result;");
                }
                builder.WriteLine("onError(s);");
                builder.WriteLine("return null;");
            }
        }
    }
}
